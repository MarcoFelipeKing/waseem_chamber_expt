distances<-c()
precision=5000 #this is delta t
#Experimental data
# initial_contamination=c(Contamination=3828) #median 34
# experimental_data = c(3840,3955,3765,3600)#c(11.5,5,2,0,6)#
# s=c(287,441,544,485)
sample_size = 1000
#parameter_sample <- c()
parameter_sample<- matrix(data=NA,nrow=1,ncol=2)
total_trials=0  #Starts the counter of run trials
accepted_trials=0 #Starts the counter for accepted trial numbers, don't change
#Loop to sample values until met the sample size
while (NROW(parameter_sample) <= sample_size){
#foreach(total_trials=1:2, .packages=c("deSolve")) %dopar% {
# The prior distributions we use are d ~ U(0.001,10.0), C ~ U(200,1200), r ~ U(0.001,1.0), g ~ U(0.001,1.0).
# We begin by sampling from these distributions and simulating the process
trial_E = runif(1,1E2,1e3)
trial_l = runif(1,0.1,3e1)
# trial_d = runif(1,1,2e2)
# trial_g = runif(1,1,2e2)
# trial_l = runif(1,1E-5,1e2)
total_trials=total_trials+1.0
#print(total_trials)
parameters=c(E=trial_E,l=trial_l) # For R code
one_run = C_star(parameters = parameters)
#Learn data from 3_1
euclidean_distance = abs(dist(rbind(one_run,data_M_3_1)))
#Learn data from 3_2
euclidean_distance = abs(dist(rbind(one_run,data_M_3_2)))+euclidean_distance
#Learn data from 6_1
euclidean_distance = abs(dist(rbind(one_run,data_M_6_1)))+euclidean_distance
#Learn data from 6_2
euclidean_distance = abs(dist(rbind(one_run,data_M_6_2)))+euclidean_distance
# parameters <- c(C = trial_C, d = trial_d, g=trial_g,r=trial_r); #For C code
# one_run = deterministic_run(precision,initial_contamination,parameters)#
#experimental_data_noP2 = [652.0, 556.0, 424.5, 467.5, 428.0, 550.0, 672.0]
# Now we find the Euclidean distance between the simulated output and the
# experimental results. delta is the threshold that the Euclidean distance
# must be less than for us to accept the trial parameters into our sample.
delta = 32000#dictates distance
#Distance(one_run, experimental_data,s)# #Distance(one_run, experimental_data,s)#_noP2)
#print(euclidean_distance)# print(parameter_sample,euclidean_distance)
#print(total_trials)
if (euclidean_distance < delta){
#parameter_sample = parameter_sample[!is.na(parameter_sample)];
parameter_sample=rbind(parameter_sample, c(trial_E,trial_l))
distances=rbind(distances,euclidean_distance)
accepted_trials=accepted_trials+1.0
print(paste0("Trial number accepted: ",accepted_trials))
}
#else{
#  print(euclidean_distance)
#  }
}
parameter_sample<-parameter_sample[order(distances), ]
parameter_sample<-parameter_sample%>%as.data.frame()#%>%set_colnames(c("r", "C", "d","g","l"))
colnames(parameter_sample)<-c("E", "l")
# return(parameter_sample)
print(paste("Summary of distances: ",distances %>% summary()))
print(paste("Percentage of accepted trials: ",accepted_trials/total_trials*100))
return(parameter_sample)
write.csv(parameter_sample,"../Data/parameter_sample.csv",row.names = FALSE)
parameter_sample %>%
pivot_longer(c(E,l),names_to="Parameter") %>%
# df_tidy<-gather(parameter_sample[,-5], Parameter, value)
ggplot(aes(x=value))+
geom_histogram(fill="#69b3a2",bins = 20,colour="gray")+
ggpubr::theme_pubclean()+
facet_wrap(~Parameter,ncol = 2,scales = "free")
#set up empty distances vector
distances<-c()
precision=5000 #this is delta t
sample_size = 1000
#parameter_sample <- c()
parameter_sample<- matrix(data=NA,nrow=1,ncol=2)
total_trials=0  #Starts the counter of run trials
accepted_trials=0 #Starts the counter for accepted trial numbers, don't change
#Loop to sample values until met the sample size
while (NROW(parameter_sample) <= sample_size){
#foreach(total_trials=1:2, .packages=c("deSolve")) %dopar% {
# The prior distributions we use are d ~ U(0.001,10.0), C ~ U(200,1200), r ~ U(0.001,1.0), g ~ U(0.001,1.0).
# We begin by sampling from these distributions and simulating the process
trial_E = runif(1,1E2,1e3)
trial_l_3_1 = runif(1,0.1,3e1)
trial_l_3_2 = runif(1,0.1,3e1)
trial_l_6_1 = runif(1,0.1,3e1)
trial_l_6_2 = runif(1,0.1,3e1)
total_trials=total_trials+1.0
#print(total_trials)
parameters_3_1=c(E=trial_E,
l_3_1=trial_l_3_1)
parameters_3_2=c(E=trial_E,
l_3_2=trial_l_3_2)
parameters_6_1=c(E=trial_E,
l_6_1=trial_l_6_1)
parameters_6_2=c(E=trial_E,
l_6_2=trial_l_6_2)
#Learn data from 3_1
one_run = C_star(parameters = parameters_3_1)
euclidean_distance = abs(dist(rbind(one_run,data_M_3_1)))
#Learn data from 3_2
one_run = C_star(parameters = parameters_3_2)
euclidean_distance = abs(dist(rbind(one_run,data_M_3_2)))+euclidean_distance
#Learn data from 6_1
one_run = C_star(parameters = parameters_6_1)
euclidean_distance = abs(dist(rbind(one_run,data_M_6_1)))+euclidean_distance
#Learn data from 6_2
one_run = C_star(parameters = parameters_6_2)
euclidean_distance = abs(dist(rbind(one_run,data_M_6_2)))+euclidean_distance
# parameters <- c(C = trial_C, d = trial_d, g=trial_g,r=trial_r); #For C code
# one_run = deterministic_run(precision,initial_contamination,parameters)#
#experimental_data_noP2 = [652.0, 556.0, 424.5, 467.5, 428.0, 550.0, 672.0]
# Now we find the Euclidean distance between the simulated output and the
# experimental results. delta is the threshold that the Euclidean distance
# must be less than for us to accept the trial parameters into our sample.
delta = 32000#dictates distance
#Distance(one_run, experimental_data,s)# #Distance(one_run, experimental_data,s)#_noP2)
#print(euclidean_distance)# print(parameter_sample,euclidean_distance)
#print(total_trials)
if (euclidean_distance < delta){
#parameter_sample = parameter_sample[!is.na(parameter_sample)];
parameter_sample=rbind(parameter_sample, c(trial_E,trial_l_3_1,trial_l_3_2,trial_l_6_1,trial_l_6_1))
distances=rbind(distances,euclidean_distance)
accepted_trials=accepted_trials+1.0
print(paste0("Trial number accepted: ",accepted_trials))
}
#else{
#  print(euclidean_distance)
#  }
}
#set up empty distances vector
distances<-c()
precision=5000 #this is delta t
sample_size = 1000
#parameter_sample <- c()
parameter_sample<- matrix(data=NA,nrow=1,ncol=4)
total_trials=0  #Starts the counter of run trials
accepted_trials=0 #Starts the counter for accepted trial numbers, don't change
#Loop to sample values until met the sample size
while (NROW(parameter_sample) <= sample_size){
#foreach(total_trials=1:2, .packages=c("deSolve")) %dopar% {
# The prior distributions we use are d ~ U(0.001,10.0), C ~ U(200,1200), r ~ U(0.001,1.0), g ~ U(0.001,1.0).
# We begin by sampling from these distributions and simulating the process
trial_E = runif(1,1E2,1e3)
trial_l_3_1 = runif(1,0.1,3e1)
trial_l_3_2 = runif(1,0.1,3e1)
trial_l_6_1 = runif(1,0.1,3e1)
trial_l_6_2 = runif(1,0.1,3e1)
total_trials=total_trials+1.0
#print(total_trials)
parameters_3_1=c(E=trial_E,
l_3_1=trial_l_3_1)
parameters_3_2=c(E=trial_E,
l_3_2=trial_l_3_2)
parameters_6_1=c(E=trial_E,
l_6_1=trial_l_6_1)
parameters_6_2=c(E=trial_E,
l_6_2=trial_l_6_2)
#Learn data from 3_1
one_run = C_star(parameters = parameters_3_1)
euclidean_distance = abs(dist(rbind(one_run,data_M_3_1)))
#Learn data from 3_2
one_run = C_star(parameters = parameters_3_2)
euclidean_distance = abs(dist(rbind(one_run,data_M_3_2)))+euclidean_distance
#Learn data from 6_1
one_run = C_star(parameters = parameters_6_1)
euclidean_distance = abs(dist(rbind(one_run,data_M_6_1)))+euclidean_distance
#Learn data from 6_2
one_run = C_star(parameters = parameters_6_2)
euclidean_distance = abs(dist(rbind(one_run,data_M_6_2)))+euclidean_distance
# parameters <- c(C = trial_C, d = trial_d, g=trial_g,r=trial_r); #For C code
# one_run = deterministic_run(precision,initial_contamination,parameters)#
#experimental_data_noP2 = [652.0, 556.0, 424.5, 467.5, 428.0, 550.0, 672.0]
# Now we find the Euclidean distance between the simulated output and the
# experimental results. delta is the threshold that the Euclidean distance
# must be less than for us to accept the trial parameters into our sample.
delta = 32000#dictates distance
#Distance(one_run, experimental_data,s)# #Distance(one_run, experimental_data,s)#_noP2)
#print(euclidean_distance)# print(parameter_sample,euclidean_distance)
#print(total_trials)
if (euclidean_distance < delta){
#parameter_sample = parameter_sample[!is.na(parameter_sample)];
parameter_sample=rbind(parameter_sample, c(trial_E,trial_l_3_1,trial_l_3_2,trial_l_6_1,trial_l_6_1))
distances=rbind(distances,euclidean_distance)
accepted_trials=accepted_trials+1.0
print(paste0("Trial number accepted: ",accepted_trials))
}
#else{
#  print(euclidean_distance)
#  }
}
#set up empty distances vector
distances<-c()
precision=5000 #this is delta t
sample_size = 1000
#parameter_sample <- c()
parameter_sample<- matrix(data=NA,nrow=1,ncol=5)
total_trials=0  #Starts the counter of run trials
#Loop to sample values until met the sample size
while (NROW(parameter_sample) <= sample_size){
#foreach(total_trials=1:2, .packages=c("deSolve")) %dopar% {
# The prior distributions we use are d ~ U(0.001,10.0), C ~ U(200,1200), r ~ U(0.001,1.0), g ~ U(0.001,1.0).
# We begin by sampling from these distributions and simulating the process
trial_E = runif(1,1E2,1e3)
trial_l_3_1 = runif(1,0.1,3e1)
trial_l_3_2 = runif(1,0.1,3e1)
trial_l_6_1 = runif(1,0.1,3e1)
trial_l_6_2 = runif(1,0.1,3e1)
total_trials=total_trials+1.0
#print(total_trials)
parameters_3_1=c(E=trial_E,
l_3_1=trial_l_3_1)
parameters_3_2=c(E=trial_E,
l_3_2=trial_l_3_2)
parameters_6_1=c(E=trial_E,
l_6_1=trial_l_6_1)
parameters_6_2=c(E=trial_E,
l_6_2=trial_l_6_2)
#Learn data from 3_1
one_run = C_star(parameters = parameters_3_1)
euclidean_distance = abs(dist(rbind(one_run,data_M_3_1)))
#Learn data from 3_2
one_run = C_star(parameters = parameters_3_2)
euclidean_distance = abs(dist(rbind(one_run,data_M_3_2)))+euclidean_distance
#Learn data from 6_1
one_run = C_star(parameters = parameters_6_1)
euclidean_distance = abs(dist(rbind(one_run,data_M_6_1)))+euclidean_distance
#Learn data from 6_2
one_run = C_star(parameters = parameters_6_2)
euclidean_distance = abs(dist(rbind(one_run,data_M_6_2)))+euclidean_distance
# parameters <- c(C = trial_C, d = trial_d, g=trial_g,r=trial_r); #For C code
# one_run = deterministic_run(precision,initial_contamination,parameters)#
# Now we find the Euclidean distance between the simulated output and the
# experimental results. delta is the threshold that the Euclidean distance
# must be less than for us to accept the trial parameters into our sample.
delta = 52000#dictates distance
#Distance(one_run, experimental_data,s)# #Distance(one_run, experimental_data,s)#_noP2)
#print(euclidean_distance)# print(parameter_sample,euclidean_distance)
#print(total_trials)
if (euclidean_distance < delta){
#parameter_sample = parameter_sample[!is.na(parameter_sample)];
parameter_sample=rbind(parameter_sample, c(trial_E,trial_l_3_1,trial_l_3_2,trial_l_6_1,trial_l_6_1))
distances=rbind(distances,euclidean_distance)
accepted_trials=accepted_trials+1.0
print(paste0("Trial number accepted: ",accepted_trials))
}
#else{
#  print(euclidean_distance)
#  }
}
#set up empty distances vector
distances<-c()
precision=5000 #this is delta t
sample_size = 1000
#parameter_sample <- c()
parameter_sample<- matrix(data=NA,nrow=1,ncol=5)
total_trials=0  #Starts the counter of run trials
accepted_trials=0 #Starts the counter for accepted trial numbers, don't change
#Loop to sample values until met the sample size
while (NROW(parameter_sample) <= sample_size){
#foreach(total_trials=1:2, .packages=c("deSolve")) %dopar% {
# The prior distributions we use are d ~ U(0.001,10.0), C ~ U(200,1200), r ~ U(0.001,1.0), g ~ U(0.001,1.0).
# We begin by sampling from these distributions and simulating the process
trial_E = runif(1,1E2,1e3)
trial_l_3_1 = runif(1,0.1,3e1)
trial_l_3_2 = runif(1,0.1,3e1)
trial_l_6_1 = runif(1,0.1,3e1)
trial_l_6_2 = runif(1,0.1,3e1)
total_trials=total_trials+1.0
#print(total_trials)
parameters_3_1=c(E=trial_E,
l_3_1=trial_l_3_1)
parameters_3_2=c(E=trial_E,
l_3_2=trial_l_3_2)
parameters_6_1=c(E=trial_E,
l_6_1=trial_l_6_1)
parameters_6_2=c(E=trial_E,
l_6_2=trial_l_6_2)
#Learn data from 3_1
one_run = C_star(parameters = parameters_3_1)
euclidean_distance = abs(dist(rbind(one_run,data_M_3_1)))
#Learn data from 3_2
one_run = C_star(parameters = parameters_3_2)
euclidean_distance = abs(dist(rbind(one_run,data_M_3_2)))+euclidean_distance
#Learn data from 6_1
one_run = C_star(parameters = parameters_6_1)
euclidean_distance = abs(dist(rbind(one_run,data_M_6_1)))+euclidean_distance
#Learn data from 6_2
one_run = C_star(parameters = parameters_6_2)
euclidean_distance = abs(dist(rbind(one_run,data_M_6_2)))+euclidean_distance
# parameters <- c(C = trial_C, d = trial_d, g=trial_g,r=trial_r); #For C code
# one_run = deterministic_run(precision,initial_contamination,parameters)#
# Now we find the Euclidean distance between the simulated output and the
# experimental results. delta is the threshold that the Euclidean distance
# must be less than for us to accept the trial parameters into our sample.
delta = 32000#dictates distance
#Distance(one_run, experimental_data,s)# #Distance(one_run, experimental_data,s)#_noP2)
#print(euclidean_distance)# print(parameter_sample,euclidean_distance)
#print(total_trials)
if (euclidean_distance < delta){
#parameter_sample = parameter_sample[!is.na(parameter_sample)];
parameter_sample=rbind(parameter_sample, c(trial_E,trial_l_3_1,trial_l_3_2,trial_l_6_1,trial_l_6_1))
distances=rbind(distances,euclidean_distance)
accepted_trials=accepted_trials+1.0
print(paste0("Trial number accepted: ",accepted_trials))
}
#else{
#  print(euclidean_distance)
#  }
}
#Loop to sample values until met the sample size
while (NROW(parameter_sample) <= sample_size){
#foreach(total_trials=1:2, .packages=c("deSolve")) %dopar% {
# The prior distributions we use are d ~ U(0.001,10.0), C ~ U(200,1200), r ~ U(0.001,1.0), g ~ U(0.001,1.0).
# We begin by sampling from these distributions and simulating the process
trial_E = runif(1,1E2,1e3)
trial_l_3_1 = runif(1,0.1,3e1)
trial_l_3_2 = runif(1,0.1,3e1)
trial_l_6_1 = runif(1,0.1,3e1)
trial_l_6_2 = runif(1,0.1,3e1)
total_trials=total_trials+1.0
#print(total_trials)
parameters_3_1=c(E=trial_E,
l_3_1=trial_l_3_1)
parameters_3_2=c(E=trial_E,
l_3_2=trial_l_3_2)
parameters_6_1=c(E=trial_E,
l_6_1=trial_l_6_1)
parameters_6_2=c(E=trial_E,
l_6_2=trial_l_6_2)
#Learn data from 3_1
one_run = C_star(parameters = parameters_3_1)
euclidean_distance = abs(dist(rbind(one_run,data_M_3_1)))
#Learn data from 3_2
one_run = C_star(parameters = parameters_3_2)
euclidean_distance = abs(dist(rbind(one_run,data_M_3_2)))+euclidean_distance
#Learn data from 6_1
one_run = C_star(parameters = parameters_6_1)
euclidean_distance = abs(dist(rbind(one_run,data_M_6_1)))+euclidean_distance
#Learn data from 6_2
one_run = C_star(parameters = parameters_6_2)
euclidean_distance = abs(dist(rbind(one_run,data_M_6_2)))+euclidean_distance
# parameters <- c(C = trial_C, d = trial_d, g=trial_g,r=trial_r); #For C code
# one_run = deterministic_run(precision,initial_contamination,parameters)#
# Now we find the Euclidean distance between the simulated output and the
# experimental results. delta is the threshold that the Euclidean distance
# must be less than for us to accept the trial parameters into our sample.
delta = 32000#dictates distance
#Distance(one_run, experimental_data,s)# #Distance(one_run, experimental_data,s)#_noP2)
#print(euclidean_distance)# print(parameter_sample,euclidean_distance)
#print(total_trials)
if (euclidean_distance < delta){
#parameter_sample = parameter_sample[!is.na(parameter_sample)];
parameter_sample=rbind(parameter_sample, c(trial_E,trial_l_3_1,trial_l_3_2,trial_l_6_1,trial_l_6_1))
distances=rbind(distances,euclidean_distance)
accepted_trials=accepted_trials+1.0
print(paste0("Trial number accepted: ",accepted_trials))
}
#else{
#  print(euclidean_distance)
#  }
}
simulate_function<-function(a){
# set.seed(seed = TRUE)
.Random.seed <- a
#set up empty distances vector
distances<-c()
precision=5000 #this is delta t
sample_size = 1000
#parameter_sample <- c()
parameter_sample<- matrix(data=NA,nrow=1,ncol=5)
total_trials=0  #Starts the counter of run trials
accepted_trials=0 #Starts the counter for accepted trial numbers, don't change
#Loop to sample values until met the sample size
while (NROW(parameter_sample) <= sample_size){
#foreach(total_trials=1:2, .packages=c("deSolve")) %dopar% {
# The prior distributions we use are d ~ U(0.001,10.0), C ~ U(200,1200), r ~ U(0.001,1.0), g ~ U(0.001,1.0).
# We begin by sampling from these distributions and simulating the process
trial_E = runif(1,1E2,1e3)
trial_l_3_1 = runif(1,0.1,3e1)
trial_l_3_2 = runif(1,0.1,3e1)
trial_l_6_1 = runif(1,0.1,3e1)
trial_l_6_2 = runif(1,0.1,3e1)
total_trials=total_trials+1.0
#print(total_trials)
parameters_3_1=c(E=trial_E,
l_3_1=trial_l_3_1)
parameters_3_2=c(E=trial_E,
l_3_2=trial_l_3_2)
parameters_6_1=c(E=trial_E,
l_6_1=trial_l_6_1)
parameters_6_2=c(E=trial_E,
l_6_2=trial_l_6_2)
#Learn data from 3_1
one_run = C_star(parameters = parameters_3_1)
euclidean_distance = abs(dist(rbind(one_run,data_M_3_1)))
#Learn data from 3_2
one_run = C_star(parameters = parameters_3_2)
euclidean_distance = abs(dist(rbind(one_run,data_M_3_2)))+euclidean_distance
#Learn data from 6_1
one_run = C_star(parameters = parameters_6_1)
euclidean_distance = abs(dist(rbind(one_run,data_M_6_1)))+euclidean_distance
#Learn data from 6_2
one_run = C_star(parameters = parameters_6_2)
euclidean_distance = abs(dist(rbind(one_run,data_M_6_2)))+euclidean_distance
# parameters <- c(C = trial_C, d = trial_d, g=trial_g,r=trial_r); #For C code
# one_run = deterministic_run(precision,initial_contamination,parameters)#
# Now we find the Euclidean distance between the simulated output and the
# experimental results. delta is the threshold that the Euclidean distance
# must be less than for us to accept the trial parameters into our sample.
delta = 32000#dictates distance
#Distance(one_run, experimental_data,s)# #Distance(one_run, experimental_data,s)#_noP2)
#print(euclidean_distance)# print(parameter_sample,euclidean_distance)
#print(total_trials)
if (euclidean_distance < delta){
#parameter_sample = parameter_sample[!is.na(parameter_sample)];
parameter_sample=rbind(parameter_sample, c(trial_E,trial_l_3_1,trial_l_3_2,trial_l_6_1,trial_l_6_1))
distances=rbind(distances,euclidean_distance)
accepted_trials=accepted_trials+1.0
print(paste0("Trial number accepted: ",accepted_trials))
}
#else{
#  print(euclidean_distance)
#  }
}
parameter_sample<-parameter_sample[order(distances), ]
parameter_sample<-parameter_sample%>%as.data.frame()#%>%set_colnames(c("r", "C", "d","g","l"))
colnames(parameter_sample)<-c("E", "l_3_1","l_3_2","l_6_1","l_6_2")
# return(parameter_sample)
print(paste("Summary of distances: ",distances %>% summary()))
print(paste("Percentage of accepted trials: ",accepted_trials/total_trials*100))
return(parameter_sample)
# return(list("parameter_sample" = parameter_sample, "distances" = distances))
}
simulate_function<-function(a){
# set.seed(seed = TRUE)
.Random.seed <- a
#set up empty distances vector
distances<-c()
precision=5000 #this is delta t
sample_size = 200
#parameter_sample <- c()
parameter_sample<- matrix(data=NA,nrow=1,ncol=5)
total_trials=0  #Starts the counter of run trials
accepted_trials=0 #Starts the counter for accepted trial numbers, don't change
#Loop to sample values until met the sample size
while (NROW(parameter_sample) <= sample_size){
#foreach(total_trials=1:2, .packages=c("deSolve")) %dopar% {
# The prior distributions we use are d ~ U(0.001,10.0), C ~ U(200,1200), r ~ U(0.001,1.0), g ~ U(0.001,1.0).
# We begin by sampling from these distributions and simulating the process
trial_E = runif(1,1E2,1e3)
trial_l_3_1 = runif(1,0.1,3e1)
trial_l_3_2 = runif(1,0.1,3e1)
trial_l_6_1 = runif(1,0.1,3e1)
trial_l_6_2 = runif(1,0.1,3e1)
total_trials=total_trials+1.0
#print(total_trials)
parameters_3_1=c(E=trial_E,
l_3_1=trial_l_3_1)
parameters_3_2=c(E=trial_E,
l_3_2=trial_l_3_2)
parameters_6_1=c(E=trial_E,
l_6_1=trial_l_6_1)
parameters_6_2=c(E=trial_E,
l_6_2=trial_l_6_2)
#Learn data from 3_1
one_run = C_star(parameters = parameters_3_1)
euclidean_distance = abs(dist(rbind(one_run,data_M_3_1)))
#Learn data from 3_2
one_run = C_star(parameters = parameters_3_2)
euclidean_distance = abs(dist(rbind(one_run,data_M_3_2)))+euclidean_distance
#Learn data from 6_1
one_run = C_star(parameters = parameters_6_1)
euclidean_distance = abs(dist(rbind(one_run,data_M_6_1)))+euclidean_distance
#Learn data from 6_2
one_run = C_star(parameters = parameters_6_2)
euclidean_distance = abs(dist(rbind(one_run,data_M_6_2)))+euclidean_distance
# parameters <- c(C = trial_C, d = trial_d, g=trial_g,r=trial_r); #For C code
# one_run = deterministic_run(precision,initial_contamination,parameters)#
# Now we find the Euclidean distance between the simulated output and the
# experimental results. delta is the threshold that the Euclidean distance
# must be less than for us to accept the trial parameters into our sample.
delta = 32000#dictates distance
#Distance(one_run, experimental_data,s)# #Distance(one_run, experimental_data,s)#_noP2)
#print(euclidean_distance)# print(parameter_sample,euclidean_distance)
#print(total_trials)
if (euclidean_distance < delta){
#parameter_sample = parameter_sample[!is.na(parameter_sample)];
parameter_sample=rbind(parameter_sample, c(trial_E,trial_l_3_1,trial_l_3_2,trial_l_6_1,trial_l_6_1))
distances=rbind(distances,euclidean_distance)
accepted_trials=accepted_trials+1.0
print(paste0("Trial number accepted: ",accepted_trials))
}
#else{
#  print(euclidean_distance)
#  }
}
parameter_sample<-parameter_sample[order(distances), ]
parameter_sample<-parameter_sample%>%as.data.frame()#%>%set_colnames(c("r", "C", "d","g","l"))
colnames(parameter_sample)<-c("E", "l_3_1","l_3_2","l_6_1","l_6_2")
# return(parameter_sample)
print(paste("Summary of distances: ",distances %>% summary()))
print(paste("Percentage of accepted trials: ",accepted_trials/total_trials*100))
return(parameter_sample)
# return(list("parameter_sample" = parameter_sample, "distances" = distances))
}
# Reset to running sequentially
plan(sequential)
plan(multisession, workers = 6)
set.seed(42)
seeds <- list(.Random.seed)
temp.list<-furrr::future_map(.x = 1:6,.f = simulate_function)
